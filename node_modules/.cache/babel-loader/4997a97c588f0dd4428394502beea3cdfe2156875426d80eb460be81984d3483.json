{"ast":null,"code":"import { get as r, set as e } from \"react-hook-form\";\nvar t = function t(e, _t, i) {\n    if (e && \"reportValidity\" in e) {\n      var n = r(i, _t);\n      e.setCustomValidity(n && n.message || \"\"), e.reportValidity();\n    }\n  },\n  i = function i(r, e) {\n    var i = function i(_i) {\n      var n = e.fields[_i];\n      n && n.ref && \"reportValidity\" in n.ref ? t(n.ref, _i, r) : n.refs && n.refs.forEach(function (e) {\n        return t(e, _i, r);\n      });\n    };\n    for (var n in e.fields) i(n);\n  },\n  n = function n(t, _n) {\n    _n.shouldUseNativeValidation && i(t, _n);\n    var f = {};\n    for (var s in t) {\n      var u = r(_n.fields, s),\n        c = Object.assign(t[s] || {}, {\n          ref: u && u.ref\n        });\n      if (a(_n.names || Object.keys(t), s)) {\n        var l = Object.assign({}, o(r(f, s)));\n        e(l, \"root\", c), e(f, s, l);\n      } else e(f, s, c);\n    }\n    return f;\n  },\n  o = function o(r) {\n    return Array.isArray(r) ? r.filter(Boolean) : [];\n  },\n  a = function a(r, e) {\n    return r.some(function (r) {\n      return r.startsWith(e + \".\");\n    });\n  };\nexport { n as toNestErrors, i as validateFieldsNatively };","map":{"version":3,"names":["t","e","i","n","r","setCustomValidity","message","reportValidity","fields","ref","refs","forEach","shouldUseNativeValidation","f","s","u","c","Object","assign","a","names","keys","l","o","Array","isArray","filter","Boolean","some","startsWith","toNestErrors","validateFieldsNatively"],"sources":["/Users/troshin/dev/Membrana2/node_modules/@hookform/resolvers/src/validateFieldsNatively.ts","/Users/troshin/dev/Membrana2/node_modules/@hookform/resolvers/src/toNestErrors.ts"],"sourcesContent":["import {\n  get,\n  FieldError,\n  ResolverOptions,\n  Ref,\n  FieldErrors,\n  FieldValues,\n} from 'react-hook-form';\n\nconst setCustomValidity = (\n  ref: Ref,\n  fieldPath: string,\n  errors: FieldErrors,\n) => {\n  if (ref && 'reportValidity' in ref) {\n    const error = get(errors, fieldPath) as FieldError | undefined;\n    ref.setCustomValidity((error && error.message) || '');\n\n    ref.reportValidity();\n  }\n};\n\n// Native validation (web only)\nexport const validateFieldsNatively = <TFieldValues extends FieldValues>(\n  errors: FieldErrors,\n  options: ResolverOptions<TFieldValues>,\n): void => {\n  for (const fieldPath in options.fields) {\n    const field = options.fields[fieldPath];\n    if (field && field.ref && 'reportValidity' in field.ref) {\n      setCustomValidity(field.ref, fieldPath, errors);\n    } else if (field.refs) {\n      field.refs.forEach((ref: HTMLInputElement) =>\n        setCustomValidity(ref, fieldPath, errors),\n      );\n    }\n  }\n};\n","import {\n  set,\n  get,\n  FieldErrors,\n  Field,\n  ResolverOptions,\n  FieldValues,\n  InternalFieldName,\n} from 'react-hook-form';\nimport { validateFieldsNatively } from './validateFieldsNatively';\n\nexport const toNestErrors = <TFieldValues extends FieldValues>(\n  errors: FieldErrors,\n  options: ResolverOptions<TFieldValues>,\n): FieldErrors<TFieldValues> => {\n  options.shouldUseNativeValidation && validateFieldsNatively(errors, options);\n\n  const fieldErrors = {} as FieldErrors<TFieldValues>;\n  for (const path in errors) {\n    const field = get(options.fields, path) as Field['_f'] | undefined;\n    const error = Object.assign(errors[path] || {}, {\n      ref: field && field.ref,\n    });\n\n    if (isNameInFieldArray(options.names || Object.keys(errors), path)) {\n      const fieldArrayErrors = Object.assign(\n        {},\n        compact(get(fieldErrors, path)),\n      );\n\n      set(fieldArrayErrors, 'root', error);\n      set(fieldErrors, path, fieldArrayErrors);\n    } else {\n      set(fieldErrors, path, error);\n    }\n  }\n\n  return fieldErrors;\n};\n\nconst compact = <TValue>(value: TValue[]) =>\n  Array.isArray(value) ? value.filter(Boolean) : [];\n\nconst isNameInFieldArray = (\n  names: InternalFieldName[],\n  name: InternalFieldName,\n) => names.some((n) => n.startsWith(name + '.'));\n"],"mappings":";AASA,IAAMA,CAAA,GAAoB,SAAAA,EACxBC,CAAA,EACAD,EAAA,EACAE,CAAA;IAEA,IAAID,CAAA,IAAO,oBAAoBA,CAAA,EAAK;MAClC,IAAME,CAAA,GAAQC,CAAA,CAAIF,CAAA,EAAQF,EAAA;MAC1BC,CAAA,CAAII,iBAAA,CAAmBF,CAAA,IAASA,CAAA,CAAMG,OAAA,IAAY,KAElDL,CAAA,CAAIM,cAAA,EACL;IAAA;EACH;EAGaL,CAAA,GAAyB,SAAAA,EACpCE,CAAA,EACAH,CAAA;IACQ,IAAAC,CAAA,YAAAA,IAAA;MAEN,IAAMC,CAAA,GAAQF,CAAA,CAAQO,MAAA,CAAON,EAAA;MACzBC,CAAA,IAASA,CAAA,CAAMM,GAAA,IAAO,oBAAoBN,CAAA,CAAMM,GAAA,GAClDT,CAAA,CAAkBG,CAAA,CAAMM,GAAA,EAAKP,EAAA,EAAWE,CAAA,IAC/BD,CAAA,CAAMO,IAAA,IACfP,CAAA,CAAMO,IAAA,CAAKC,OAAA,CAAQ,UAACV,CAAA;QAAqB,OACvCD,CAAA,CAAkBC,CAAA,EAAKC,EAAA,EAAWE,CAAA,CAAO;MAAA,EAG9C;IAAA;IATD,KAAK,IAAMD,CAAA,IAAaF,CAAA,CAAQO,MAAA,EAAMN,CAAA,CAAAC,CAAA,CAUxC;EAAA;EC1BaA,CAAA,GAAe,SAAAA,EAC1BH,CAAA,EACAG,EAAA;IAEAA,EAAA,CAAQS,yBAAA,IAA6BV,CAAA,CAAuBF,CAAA,EAAQG,EAAA;IAEpE,IAAMU,CAAA,GAAc,CAA+B;IACnD,KAAK,IAAMC,CAAA,IAAQd,CAAA,EAAQ;MACzB,IAAMe,CAAA,GAAQX,CAAA,CAAID,EAAA,CAAQK,MAAA,EAAQM,CAAA;QAC5BE,CAAA,GAAQC,MAAA,CAAOC,MAAA,CAAOlB,CAAA,CAAOc,CAAA,KAAS,IAAI;UAC9CL,GAAA,EAAKM,CAAA,IAASA,CAAA,CAAMN;QAAA;MAGtB,IAAIU,CAAA,CAAmBhB,EAAA,CAAQiB,KAAA,IAASH,MAAA,CAAOI,IAAA,CAAKrB,CAAA,GAASc,CAAA,GAAO;QAClE,IAAMQ,CAAA,GAAmBL,MAAA,CAAOC,MAAA,CAC9B,CAAE,GACFK,CAAA,CAAQnB,CAAA,CAAIS,CAAA,EAAaC,CAAA;QAG3Bb,CAAA,CAAIqB,CAAA,EAAkB,QAAQN,CAAA,GAC9Bf,CAAA,CAAIY,CAAA,EAAaC,CAAA,EAAMQ,CAAA,CACxB;MAAA,OACCrB,CAAA,CAAIY,CAAA,EAAaC,CAAA,EAAME,CAAA,CAE1B;IAAA;IAED,OAAOH,CACT;EAAA;EAEMU,CAAA,GAAU,SAAVA,EAAmBnB,CAAA;IACvB,OAAAoB,KAAA,CAAMC,OAAA,CAAQrB,CAAA,IAASA,CAAA,CAAMsB,MAAA,CAAOC,OAAA,IAAW,EAAE;EAAA;EAE7CR,CAAA,GAAqB,SAArBA,EACJf,CAAA,EACAH,CAAA;IAAuB,OACpBG,CAAA,CAAMwB,IAAA,CAAK,UAACxB,CAAA;MAAM,OAAAA,CAAA,CAAEyB,UAAA,CAAW5B,CAAA,GAAO,IAAI;IAAA,EAAC;EAAA;AAAA,SAAAE,CAAA,IAAA2B,YAAA,EAAA5B,CAAA,IAAA6B,sBAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}